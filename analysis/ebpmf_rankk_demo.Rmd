---
title: "ebpmf_rankk_demo"
author: "zihao12"
date: "2019-10-01"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---


```{r}
library(ebpm)
library(matrixStats)
```


```{r}
## Note: in rank1 case, what we need is just row and  column sum of X

## TODO: 
## 1. think about how to store qg. They include:
# qls_mean_log = matrix(replicate(n*K, 0), ncol =  K)
# qfs_mean_log = matrix(replicate(p*K, 0), ncol =  K)
# qls_mean = matrix(replicate(n*K, 0), ncol =  K)
# qfs_mean = matrix(replicate(p*K, 0), ncol =  K)
# # ... gls, gfs

## 2. think about the importance of initialization, and how to

ebpmf_rankk_exponential <- function(X, K, m, init, maxiter.out = 10, maxiter.int = 1, seed){
  X = as(X, "dgTMatrix") ## triplet representation: i,j, x
  set.seed(123)
  qg = init
  for(i in 1:maxiter.out){
    for(k in 1:K){
      ## get row & column sum of <Z_ijk>
      Ez = get_Ez(X, qg, k) 
      ## update q, g
      tmp = ebpmf_rank1_exponential_helper(Ez$rsum,Ez$csum,qg$qls_mean[,k],m, maxiter.int) ## need to deal with (manipulate) sparse matrix
      qg = update_qg(tmp, qg, k)
    }
  }
  return(qg)
}

## compute the row & col sum of <Z_ijk> for a given k
## since <Z_ijk> != 0 only if X_ij != 0, we only need to loop over nonzero elements of X
get_Ez <- function(X, qg, k){
  rsum = replicate(nrow(x), 0)
  csum = replicate(ncol(x), 0)
  for(l in 1:length(X@i)){
    i = X@i[l]
    j = X@j[l]
    current = X[i,j] * softmax1d(qg$qls_mean_log[i,] + qg$qfs_mean_log[j,])[k] ## <Z_ijk> = X_ij * psi_ijk
    rsum[i] = rsum[i] + current
    csum[j] = csum[j] + current
  }
  return(list(rsum = rsum, csum = csum))
}

softmax1d <- function(x){
  return(exp(x - logSumExp(x)))
}

update_qg <- function(tmp, qg, k){
  qg$qls_mean[,k] = tmp$ql$mean
  qg$qls_mean_log[,k] = tmp$ql$mean_log
  qg$qfs_mean[,k] = tmp$qf$mean
  qg$qfs_mean_log[,k] = tmp$qf$mean_log
  qg$gls[[k]] = tmp$gl
  qg$gfs[[k]] = tmp$gf
  return(qg)
}

# X: a matrix/array of shape n by p 
# different in that only row and column sum of X is provided
ebpmf_rank1_exponential_helper <- function(X_rowsum,X_colsum, init, m = 2, maxiter = 1){
  #El = init$ql$mean
  ql = init
  #E_f = get_exp_F(init)
  for(i in 1:maxiter){
    ## update q(f), g(f)
    sum_El = sum(ql$mean)
    tmp = ebpm_exponential_mixture(x = X_colsum, s = replicate(p,sum_El), m = m)
    qf = tmp$posterior
    gf = tmp$fitted_g
    ll_f = tmp$log_likelihood
    ## update q(l), g(l)
    sum_Ef = sum(qf$mean)
    tmp = ebpm_exponential_mixture(x = X_rowsum, s = replicate(n,sum_Ef), m = m)
    ql = tmp$posterior
    gl = tmp$fitted_g
    ll_l = tmp$log_likelihood
    qg = list(ql = ql, gl = gl, qf = qf, gf = gf, ll_f = ll_f, ll_l = ll_l)
    # elbo = compute_elbo(X, qg)
    # print(sprintf("ELBO: %f", elbo))
  }
  return(qg)
}

```








