---
title: "ebpm_demo"
author: "zihao12"
date: "2019-09-23"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## EBPM problem
see detail in  ...

```{r}
library(mixsqp)
library(ggplot2)
library(gtools)
#library(bsts)
```


## EBPM-gamma
* For now, I use mixture of exponential as prior family.
* Under the exponential case, we discuss how to select the range of  the grid (of $\mu$). For convenience we use $exp(\mu)$ to denote exponential distribution with mean $\mu$:\
The goal is: for each observation, we want to include the range of $\lambda$ "of  interest" (i.e. $log \ p(x | \lambda)$ is  close to that of the MLE, like within $log(0.1)$). 
If $x = 0$, $\ell(\lambda) = - \lambda s$, in order to  have a good likelihood, we want the model to be able to choose  $\lambda \sim o(\frac{1}{s})$. Therefore, we want the smallest $\mu$ to be  in the order of $o(\frac{1}{s})$ if there  is 0 count.\
If $x > 0$, the MLE would be $\frac{x}{s}$, and $\lambda$ too small would have bad likelihood. So we want the biggest $\mu$ to be of order $O(max(\frac{x}{s}))$


```{r}
compute_L <- function(x, s,a, b){
  M1 = (s^x)/gamma(x + 1)
  M2 = (b^a)/gamma(a)
  ak_add_xi = outer(x,a, "+")
  M3 = gamma(ak_add_xi)/outer(s,b, "+")^ak_add_xi
  out = outer(M1, M2, "*") * M3
  return(out)
}

## generate a geometric sequence: x_n = low*m^{n-1} up to x_n < up
geom_seq <- function(low, up, m){
  N =  ceiling(log(up/low)/log(m)) + 1
  out  = low*m^(seq(1,N, by = 1)-1)
  return(out)
}

select_grid <- function(x, s, m = 2){
  ## mu_grid: mu =  1/b
  x_d_s = x/s
  xprime = x
  xprime[x == 0] = xprime[x == 0] + 1
  xprime_d_s = xprime/s
  #mu_grid = seq(0.1*min(xprime_d_s),2*max(x_d_s), length.out = nv)
  mu_grid_min =  0.1*min(xprime_d_s)
  mu_grid_max = 2*max(x_d_s)
  mu_grid = geom_seq(mu_grid_min, mu_grid_max, m)
  
  a = rep(1,length(mu_grid))
  b = 1/mu_grid
  return(list(a = a, b  = b))
}

ebpm <- function(x,s,nv = 100, grid = NULL, seed = 123){
  set.seed(seed)
  if(is.null(grid)){grid <- select_grid(x,s,nv)}
  a = grid$a
  b =  grid$b
  L <-  compute_L(x,s,a,b)
  fit <- mixsqp(L, control = list(verbose = FALSE))
  pi = fit$x
  cpm = outer(x,a)/outer(s, b)
  pm = cpm %*% pi
  return(list(pi = pi, pm = pm, L = L, a  = a, b = b))
}
```


```{r}
## simulate from a mixture of gamma, with weight generated from a dirichlet 
sim_mgamma <- function(grid, pi){
  a = grid$a
  b = grid$b
  idx = which(rmultinom(1,1, pi) == 1)
  return(rgamma(n = 1,shape = a[idx], rate = b[idx]))
}


simulate_pm  <-  function(grid = NULL, seed = 123){
  set.seed(seed)
  if(is.null(grid)){lam_true <- c(rep(0,199),seq(0,10,0.05)); pi = NULL}
  else{
    n_component = length(grid$a)
    pi <- rdirichlet(1,rep(1/n_component, n_component))
    lam_true <- rep(sim_mgamma(grid, pi), 400)
  }
  #s  = runif(length(lam_true))
  s = rep(1, length(lam_true))
  x  = rpois(length(lam_true),s*lam_true)
  return(list(x =  x, s = s, lam_true = lam_true, pi = pi))
}
```

### lam_true from 0 and linspace
```{r}
sim = simulate_pm()
x = sim$x 
s = sim$s
lam_true = sim$lam_true
fit = ebpm(x, s)

df = data.frame(n = 1:length(x), x = x, lam_true = lam_true, lam_hat = fit$pm)

ggplot(df)  + geom_point(aes(x = n, y = log10(lam_true+1), color = "true"), cex = 0.5) +
               geom_point(aes(x = n, y = log10(x+1), color = "x"), cex = 0.5) +
               geom_point(aes(x = n, y = log10(lam_hat+1), color = "lam_hat"), cex = 0.5) +
               labs(x = "index", y = "log10(lam + 1)", title = "EBPM") +
               guides(fill = "color")

ggplot(df)  + geom_point(aes(x = x, y = lam_hat, color = "blue"), cex = 0.5) +
               labs(x = "x", y = "lam_hat", title = "EBPM") +
               guides(fill = "color")+
                geom_abline(slope = 1)
```


### lam_true from mixture of gamma (same as grids chosen by the model)
I generate "lam_true" from a mixture of gamma. Then I give the gamma components (grids) to the model. So we can see if the model estimates mixture weights properly
```{r include = FALSE}
n_component = 20
a = rep(1, n_component)
b = 10*runif(n_component)
grid = list(a = a, b = b)
sim <- simulate_pm(grid)
fit = ebpm(sim$x, sim$s, grid = grid, nv = 100)
```

```{r include = FALSE}
df = data.frame(n = 1:length(sim$x), x = sim$x, lam_true = sim$lam_true, lam_hat = fit$pm)
ggplot(df)  + geom_point(aes(x = n, y = log10(lam_true+1), color = "true"), cex = 0.5) +
               geom_point(aes(x = n, y = log10(x+1), color = "x"), cex = 0.5) +
               geom_point(aes(x = n, y = log10(lam_hat+1), color = "lam_hat"), cex = 0.5) +
               labs(x = "index", y = "log10(lam + 1)", title = "EBPM") +
               guides(fill = "color")

ggplot(df)  + geom_point(aes(x = x, y = lam_hat, color = "blue"), cex = 0.5) +
               labs(x = "x", y = "lam_hat", title = "EBPM") +
               guides(fill = "color")+
                geom_abline(slope = 1)
#plot(log10(fit$pi), log10(sim$pi))
```




















