---
title: "ebpm_point_gamma_demo"
author: "zihao12"
date: "2019-09-28"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r}
library(stats)
library(ggplot2)
set.seed(123)
```


## ebpm with spike-and-slab prior

## EBPM problem
$$
\begin{align}
  & x_i \sim Pois(s_i \lambda_i)\\
  & \lambda_i \sim g(.)\\
  & g \in \mathcal{G}
\end{align}
$$

where $\mathcal{G} = \{\pi_0 \delta(.) + (1-\pi_0) gamma(a,b): \pi_0 \in  [0,1] \}$\

Now the goal is to compute  $\hat{\pi}_0,\hat{a}, \hat{b}$ with MLE, then compute posterior mean of $\lambda_i$. 

### MLE
$$
\begin{align}
  & l(\pi_0, a, b) = \sum_i log \{\pi_0 c_i(a, b) +  d_i(a, b) \}\\
  & d_i(a, b)  := NB(x_i, a, \frac{b}{b + s})\\
  & c_i  := \delta(x_i) - d_i(a,b)
\end{align}
$$
#### functions for optimization in "nlm"
```{r}
pg_nlm_fn <- function(par, x, s){
  pi = log(par[1]) - log(1-par[1])
  a = par[2]
  b  =  exp(par[3])
  d <- dnbinom(x, a, b/(b+s), log = F) 
  c = as.integer(x ==  0) - d
  return(-sum(log(pi*c + d)))
}

transform_param <- function(par0){
  par = rep(0,length(par0))
  par[1] = 1/(1+exp(-par0[1]))
  par[2] = par0[2]
  par[3] = log(par0[3])
  return(par)
}

transform_param_back <- function(par){
  par0 = rep(0,length(par))
  par0[1] = log(par[1]) - log(1-par[1])
  par0[2] = par[2]
  par0[3] = exp(par[3])
  return(par0)
}
```


```{r}
sim_spike_one <- function(pi, a, b){
  if(rbinom(1,1, pi)){return(0)}
  else{return(rgamma(1,shape = a, rate = b))}
}

simulate_pm <- function(s, param){
  pi = param[1]
  a = param[2]
  b  = param[3]
  lam = replicate(length(s), sim_spike_one(pi, a, b))
  x = rpois(length(s), s*lam)
  ll = pg_nlm_fn(param, x, s)
  return(list(x = x, s= s, lam = lam, param = param, ll = ll))
}
```

```{r}
n = 1000
s = replicate(n, 1)
pi  = 0.8
a = 100
b  = 1
param =  c(pi, a, b)
sim = simulate_pm(s, param)
```

```{r warning=FALSE}
init_par = c(0.5,1,1)
opt = nlm(pg_nlm_fn, transform_param(init_par), sim$x, sim$s)
opt_par = transform_param_back(opt$estimate)

print(sprintf("oracle ll: %f", -pg_nlm_fn(transform_param(sim$param), sim$x, sim$s)))
print(sprintf("opt    ll: %f", -pg_nlm_fn(transform_param(opt_par), sim$x, sim$s)))

print("oracle:")
print(c(pi, a, b))
print("estimate")
print(opt_par)

```

##### Comment:
* Estimated parameter gets better loglikelihood than oracle, and is similar to oracle (in a sense). 
* However, there are some warnings in the process. 
* To do: add gradient and Hessian

## Wrap up into ebpm algorithm
It is easy to deduce posterior mean:

$$
\begin{align}
  \text{posterior mean} = (1-\pi_0)NB(x; a, \frac{b}{b + s}) \frac{a+x}{b+s}
\end{align}
$$

```{r}
ebpm_point_gamma <- function(x, s, init_par = c(0.5,1,1), seed = 123){
  set.seed(seed) ## though seems determined
  ## MLE
  opt = nlm(pg_nlm_fn, transform_param(init_par), x, s)
  opt_par = transform_param_back(opt$estimate)
  ll =  -pg_nlm_fn(transform_param(opt_par), x, s)

  ## posterior mean
  pi = opt_par[1]
  a =  opt_par[2]
  b =  opt_par[3]
  pm = (1-pi)*dnbinom(x, size = a, prob = b/(b+s))*(a+x)/(b+s)
  return(list(param = opt_par, lam_pm = pm, ll = ll))
}
```

```{r warning=FALSE}
fit <- ebpm_point_gamma(sim$x, sim$s)
```


```{r}
df <- data.frame(n = 1:length(sim$x), x = sim$x, s = sim$s, lam = sim$lam, lam_pm = fit$lam_pm)
ggplot(df)  + geom_point(aes(x = x/s, y = lam_pm), color = "blue", cex = 0.5) +
    labs(x = "x/s", y = "lam_pm", title = "ebpm_point_gamma") +
    guides(fill = "color")
```

##### Comment
Clearly wrong in posterior mean.
